"use strict";(self.webpackChunkknowledgebase=self.webpackChunkknowledgebase||[]).push([[7016],{61599:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>o});var t=i(85893),r=i(11151);const s={title:"Test First",aliases:null,tags:["cleancode","cleancode/ccd","cleancode/ccd/practic"]},d="Test First",a={id:"main/CleanCode/CleanCodeDeveloper/Praktiken/Test First",title:"Test First",description:"Warum?",source:"@site/docs/main/CleanCode/CleanCodeDeveloper/Praktiken/Test First.md",sourceDirName:"main/CleanCode/CleanCodeDeveloper/Praktiken",slug:"/main/CleanCode/CleanCodeDeveloper/Praktiken/Test First",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Praktiken/Test First",draft:!1,unlisted:!1,tags:[{label:"cleancode",permalink:"/docs/tags/cleancode"},{label:"cleancode/ccd",permalink:"/docs/tags/cleancode-ccd"},{label:"cleancode/ccd/practic",permalink:"/docs/tags/cleancode-ccd-practic"}],version:"current",frontMatter:{title:"Test First",aliases:null,tags:["cleancode","cleancode/ccd","cleancode/ccd/practic"]},sidebar:"cs",previous:{title:"Statical Code Analysis",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Praktiken/Statical Code Analysis"},next:{title:"Version Control System",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Praktiken/Version Control System"}},l={},o=[];function c(e){const n={a:"a",blockquote:"blockquote",em:"em",h1:"h1",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"test-first",children:"Test First"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Warum?"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Der Kunde ist K\xf6nig und bestimmt die Form einer Dienstleistung. Service-Implementationen sind also nur passgenau, wenn sie durch einen Client getrieben werden."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Wenn Komponentenorientierung fordert, die Kontrakte f\xfcr Komponenten unabh\xe4ngig von ihrer Implementation zu definieren, stellt sich die Frage, wie das denn geschehen soll. Durch Diskussion am runden Tisch? Das ist sicherlich ein Weg. Ein besserer ist jedoch, Kontrakte nicht erst lange an einer Tafel zu entwerfen, sondern sie sofort in Code zu gie\xdfen. Komponentenkontrakte \u2013 oder allgemeiner: jede Codeschnittstelle \u2013 dient letztlich anderem Code als API. Es ist daher konsequent und effektiv, von diesem Code ausgehend Schnittstellen zu spezifizieren."}),"\n",(0,t.jsxs)(n.p,{children:["Das ist das Anliegen von\xa0",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Praktiken/Test%20First",children:"Test First"})}),". Test first basiert auf dem Gedanken, dass Funktionseinheiten (Methoden, Klassen, usw.) durch Client-Service-Verh\xe4ltnisse charakterisiert sind. Diese Verh\xe4ltnisse drehen sich um die Schnittstelle zwischen Client und Service. Und diese Schnittstelle sollte durch den Client bestimmt werden. Der Client ist als Kunde des Service K\xf6nig. Ihm soll der Service dienen, nach ihm soll sich deshalb die Schnittstelle des Service richten."]}),"\n",(0,t.jsx)(n.p,{children:"Die Definition der Schnittstellen der Codeeinheiten einer Software erfolgt aus diesem Grund von au\xdfen nach innen. Au\xdfen, an der Benutzeroberfl\xe4che, sitzt der ultimative Client, der Anwender. Er definiert die visuelle/haptische Schnittstelle der UI-Codeeinheiten. Die wiederum sind die Clients von darunterliegenden Codeschichten. Die sind dann Clients von tieferliegenden Schichten usw. Die Leistungen und Schnittstellen der tiefsten Codeschichten kann somit nur bestimmt werden, wenn die der dar\xfcberliegenden schon bestimmt sind usw."}),"\n",(0,t.jsx)(n.p,{children:"Das widerspricht dem h\xe4ufigen Ansatz der bottom-up Definition von Codeeinheiten. Gern fangen Projekte an, eine Datenzugriffsschicht zu definieren und zu implementieren. Das ist verst\xe4ndlich, weil solch fundamentale Funktionalit\xe4t doch scheinbar die Voraussetzung f\xfcr alles weitere ist. Aber dieses Vorgehen ist problematisch, wie viele gescheiterte Projekte zeigen:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Wer von unten nach oben, von innen nach au\xdfen spezifiziert und implementiert, bietet dem Kunden erst sehr sp\xe4t einen Wert an. Das ist zumindest frustrierend, wenn nicht gar kontraproduktiv."}),"\n",(0,t.jsxs)(n.li,{children:["Wer bottom-up in der Spezifikation vorgeht, der spezifiziert ohne genaue Anforderungen des ultimativen Clients, des Benutzers. Was er also spezifiziert l\xe4uft Gefahr, am Ende zu allgemein und damit unhandlich zu sein \u2013 oder schlicht nicht gebraucht zu werden (eine Verletzung des ",(0,t.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/You%20Aint%20Gonna%20Need%20It",children:"YAGNI"}),"-Prinzips, s.o. und im\xa0",(0,t.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Grade/Roter%20Grad",children:"roten Grad"})]}),"\n",(0,t.jsxs)(n.li,{children:["Wer von unten nach oben implementiert, l\xe4uft Gefahr, nicht wirklich zu entkoppeln. Denn wenn tiefere Schichten n\xf6tig sind, um dar\xfcberliegende zu implementieren, dann werden wahrscheinlich keine wirklich isolierten ",(0,t.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper%20Test",children:"Unit Tests"})," mit Attrappen eingesetzt und auch keine Inversion of Control."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper",children:"CleanCodeDeveloper"})," vermeiden diese Probleme jedoch. Sie spezifizieren Schnittstelle nicht nur vor den Implementationen (Contract-first, s.o. Komponentenorientierung), sondern auch von au\xdfen nach innen und ganz praktisch durch Codierung. Mit den Mitteln des automatisierten Testens ist es n\xe4mlich sehr einfach, Schnittstellen in kleinen Schritten in Form von Tests zu definieren."]}),"\n",(0,t.jsx)(n.p,{children:"Test first f\xfcgt dadurch syntaktischen Kontrakten (z.B. Interfaces) eine semantische Seite hinzu. In Ermangelung anderer, formaler Methoden, um Semantik zu spezifizieren, sind Tests der einzige Weg, um Anforderungen zu formalisieren. Wer einem Entwickler eine Komponente zur Implementierung zuweisen will, der tut daher gut daran, nicht nur ihre \u201eOberfl\xe4che\u201c (API) syntaktisch vorzugeben, sondern auch das gew\xfcnschte Verhalten in Form von Tests."}),"\n",(0,t.jsx)(n.p,{children:"Das hat viele Vorteile:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Die Form einer Schnittstelle ist unmittelbar Client-getrieben und damit maximal relevant. ",(0,t.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/You%20Aint%20Gonna%20Need%20It",children:"YAGNI"})," hat keine Chance."]}),"\n",(0,t.jsxs)(n.li,{children:["Die Tests sind nicht nur Tests, sondern auch Spezifikationsdokumentation. Nutzer einer Schnittstelle und Implementierer k\xf6nnen sie gleicherma\xdfen studieren. Eine separate Dokumentation er\xfcbrigt sich weitgehend. Das tut dem ",(0,t.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/DRY",children:"DRY"}),"-Prinzip gen\xfcge."]}),"\n",(0,t.jsx)(n.li,{children:"Die Spezifikationen sind nicht nur passive Texte, sondern ausf\xfchrbarer Code. Wenn dann eine Implementation vorliegt, kann sie gegen diese Tests gepr\xfcft werden. Spezifikation und Test sind damit nicht zeitraubend aufeinanderfolgende Phasen. Das erh\xf6ht die Produktivit\xe4t. Qualit\xe4tssicherung ist so der Implementation schon vorgeschaltet."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Siehe auch unter\xa0",(0,t.jsx)(n.a,{href:"https://clean-code-developer.de/weitere-infos/werkzeuge/",children:"Tools"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Weiter geht\u2019s mit dem\xa0",(0,t.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Grade/Wei%C3%9Fer%20Grad",children:"wei\xdfen Grad"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>d});var t=i(67294);const r={},s=t.createContext(r);function d(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);