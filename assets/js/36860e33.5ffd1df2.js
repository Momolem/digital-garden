"use strict";(self.webpackChunkknowledgebase=self.webpackChunkknowledgebase||[]).push([[6822],{44657:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var i=o(85893),t=o(11151);const r={title:"Favour Composition over Inheritance",tags:["cleancode","cleancode/ccd","cleancode/ccd/principle"]},a="Favour Composition over Inheritance (FCoI)",s={id:"main/CleanCode/CleanCodeDeveloper/Prinzipien/Favour Composition over Inheritance",title:"Favour Composition over Inheritance",description:"Warum?",source:"@site/docs/main/CleanCode/1. CleanCodeDeveloper/Prinzipien/Favour Composition over Inheritance.md",sourceDirName:"main/CleanCode/1. CleanCodeDeveloper/Prinzipien",slug:"/main/CleanCode/CleanCodeDeveloper/Prinzipien/Favour Composition over Inheritance",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Favour Composition over Inheritance",draft:!1,unlisted:!1,tags:[{label:"cleancode",permalink:"/docs/tags/cleancode"},{label:"cleancode/ccd",permalink:"/docs/tags/cleancode-ccd"},{label:"cleancode/ccd/principle",permalink:"/docs/tags/cleancode-ccd-principle"}],version:"current",frontMatter:{title:"Favour Composition over Inheritance",tags:["cleancode","cleancode/ccd","cleancode/ccd/principle"]},sidebar:"cs",previous:{title:"Design and Implementation Don't Overlapp",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Design and Implementation Dont Overlapp"},next:{title:"Implementation Reflects Design",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Implementation Reflects Design"}},l={},c=[];function d(e){const n={a:"a",blockquote:"blockquote",em:"em",h1:"h1",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"favour-composition-over-inheritance-fcoi",children:"Favour Composition over Inheritance (FCoI)"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Warum?"}),"\nKomposition f\xf6rdert die lose Kopplung und die Testbarkeit eines Systems und ist oft flexibler."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["F\xfcr die Wiederverwendung von Funktionalit\xe4t kennt die Objektorientierte Programmierung (",(0,i.jsx)(n.a,{href:"OOP",children:"OOP"}),") zwei sehr bekannte Kandidaten: Die Vererbung (whitebox \u2013 reuse) und die Komposition (blackbox \u2013 reuse). Verwendet man Funktionalit\xe4t wieder durch das Ableiten von einer Klasse, so ist die Subklasse abh\xe4ngig von der Elternklasse. Dies macht ein System in vielen F\xe4llen unn\xf6tig komplex, schlechter testbar und erschwert das Austauschen von Funktionalit\xe4t zur Laufzeit. ",(0,i.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/CleanCodeDeveloper",children:"CleanCodeDeveloper"})," hat f\xfcr das korrekte Ableiten das ",(0,i.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Praktiken/Liskov%20Substitution%20Principle",children:"Liskov Substitution Principle"})," bereit, das es dabei zu befolgen gilt."]}),"\n",(0,i.jsx)(n.p,{children:"Bei der Komposition verwendet eine Klasse eine andere. Verwendet man dazu eine klar definierte Schnittstelle, f\xf6rdert das die Entkopplung. Auch k\xf6nnen verschiedene Implementationen einfach ausgetauscht werden. Bevor man sich also der  stellt, fordert Favour Composition over Inheritance, sich die Frage zu stellen, ob man der Komposition nicht Vorrang geben kann."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["\u201e",(0,i.jsx)(n.em,{children:"Because inheritance exposes a subclass to details of its parent\u2019s implementation, it\u2019s often said that \u201ainheritance breaks encapsulation"}),"\u201e. (Gang of Four 1995:19)"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,n,o)=>{o.d(n,{Z:()=>s,a:()=>a});var i=o(67294);const t={},r=i.createContext(t);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);