"use strict";(self.webpackChunkknowledgebase=self.webpackChunkknowledgebase||[]).push([[6939],{91106:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var t=i(85893),r=i(11151);const a={title:"Design and Implementation Don't Overlapp",aliases:null,tags:["cleancode","cleancode/ccd","cleancode/ccd/principle"]},o="Design and Implementation Don\u2019t Overlapp",l={id:"main/CleanCode/CleanCodeDeveloper/Prinzipien/Design and Implementation Dont Overlapp",title:"Design and Implementation Don't Overlapp",description:"Warum?",source:"@site/docs/main/CleanCode/1. CleanCodeDeveloper/Prinzipien/Design and Implementation Dont Overlapp.md",sourceDirName:"main/CleanCode/1. CleanCodeDeveloper/Prinzipien",slug:"/main/CleanCode/CleanCodeDeveloper/Prinzipien/Design and Implementation Dont Overlapp",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Design and Implementation Dont Overlapp",draft:!1,unlisted:!1,tags:[{label:"cleancode",permalink:"/docs/tags/cleancode"},{label:"cleancode/ccd",permalink:"/docs/tags/cleancode-ccd"},{label:"cleancode/ccd/principle",permalink:"/docs/tags/cleancode-ccd-principle"}],version:"current",frontMatter:{title:"Design and Implementation Don't Overlapp",aliases:null,tags:["cleancode","cleancode/ccd","cleancode/ccd/principle"]},sidebar:"cs",previous:{title:"Dependency Inversion Principle",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Dependency Inversion Principle"},next:{title:"Favour Composition over Inheritance",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Favour Composition over Inheritance"}},s={},d=[];function c(e){const n={a:"a",blockquote:"blockquote",h1:"h1",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"design-and-implementation-dont-overlapp",children:"Design and Implementation Don\u2019t Overlapp"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Warum?"}),"\nPlanungsunterlagen, die mit der Umsetzung nichts mehr gemein haben, schaden mehr, als dass sie n\xfctzen. Deshalb nicht die Planung aufgeben, sondern die Chance auf Inkonsistenz minimieren."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Eines der grundlegenden Probleme der Softwareentwicklung sind Implementationen, denen eine vorausgegangene Planung nicht mehr anzusehen ist. Da h\xe4ngen dann Entwurfsdiagramme an der Wand, die kaum noch etwas mit der Coderealit\xe4t zu tun haben. Die Ursache daf\xfcr ist eine Verletzung des fundamentalen ",(0,t.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/DRY",children:"DRY"}),"-Prinzips: Entwurf und Implementation sind Wiederholungen desselben, der Struktur einer Software. Da Implementation auf Entwurf folgt und den L\xf6wenanteil der Arbeit ausmacht, geraten beide schnell aus dem Tritt, wenn Struktur\xe4nderungen w\xe4hrend der Implementation nicht immer wieder in den Entwurf eingearbeitet werden. Entwurfsdiagramme sind nach Beginn der Implementation sonst bald nichts mehr wert."]}),"\n",(0,t.jsxs)(n.p,{children:["Wie kann die Situation verbessert werden? Sollte vielleicht auf Entwurf verzichtet werden, wenn letztlich in der Implementation die \u201eStrukturwahrheit\u201c liegt? Nein, sicher nicht. Entwurf muss sein. Ohne Planung gibt es keine Zielvorstellung. Aber Entwurf und Implementation m\xfcssen dem ",(0,t.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/DRY",children:"DRY"}),"-Prinzip gerecht werden. Deshalb sollten Entwurf und Implementation sich so wenig \xfcberlappen wie m\xf6glich. Ihre Schnittstelle sollte d\xfcnn sein. Wenn das der Fall ist, stellen sie keine Wiederholungen mehr dar, sondern beschreiben unterschiedliches. Das bedeutet: Entwurf/Architektur k\xfcmmert sich nicht um die Implementation und Implementation k\xfcmmert sich nicht um Architektur."]}),"\n",(0,t.jsx)(n.p,{children:"Und wo verl\xe4uft diese Trennlinie? Bei den so genannten Komponenten (s.u. Praktiken). Architekten k\xfcmmern sich nicht um den internen Aufbau von Komponenten. F\xfcr sie sind es Black Boxes, deren Klassenstruktur nicht architekturrelevant ist. Umgekehrt ist f\xfcr einen Komponentenimplementierer die Architektur irrelevant. Was er zu implementieren hat, ergibt sich aus den Komponentenkontrakten, die seine Komponente importiert und exportiert. Einen gr\xf6\xdferen Zusammenhang muss er nicht kennen."}),"\n",(0,t.jsx)(n.p,{children:"Die Aufgabe der Architektur ist es mithin, Software in Komponenten zu zerlegen, deren Abh\xe4ngigkeiten zu definieren und Leistungen in Kontrakten zu beschreiben. Diese Strukturen werden dann auch einzig durch Architekten gepflegt. Und die Aufgabe der Implementation ist es, die von der Architektur definierten Komponenten zu realisieren. Wie sie das tun, ist nicht architekturrelevant. Ihre innere Struktur ist f\xfcr die Architektur unsichtbar."})]})}function m(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>o});var t=i(67294);const r={},a=t.createContext(r);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);