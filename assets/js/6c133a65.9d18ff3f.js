"use strict";(self.webpackChunkknowledgebase=self.webpackChunkknowledgebase||[]).push([[167],{66586:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var r=t(85893),i=t(11151);const s={title:"Automated Integrationtests",aliases:null,tags:["cleancode","cleancode/ccd","cleancode/ccd/practic"]},a="Automated Integrationtests",o={id:"main/CleanCode/CleanCodeDeveloper/Praktiken/Automated Integrationtests",title:"Automated Integrationtests",description:"Warum?",source:"@site/docs/main/CleanCode/1. CleanCodeDeveloper/Praktiken/Automated Integrationtests.md",sourceDirName:"main/CleanCode/1. CleanCodeDeveloper/Praktiken",slug:"/main/CleanCode/CleanCodeDeveloper/Praktiken/Automated Integrationtests",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Praktiken/Automated Integrationtests",draft:!1,unlisted:!1,tags:[{label:"cleancode",permalink:"/docs/tags/cleancode"},{label:"cleancode/ccd",permalink:"/docs/tags/cleancode-ccd"},{label:"cleancode/ccd/practic",permalink:"/docs/tags/cleancode-ccd-practic"}],version:"current",frontMatter:{title:"Automated Integrationtests",aliases:null,tags:["cleancode","cleancode/ccd","cleancode/ccd/practic"]},sidebar:"cs",previous:{title:"Legacy Code",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Legacy Code"},next:{title:"Automated Unit Tests",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Praktiken/Automated Unit Tests"}},d={},l=[];function c(e){const n={a:"a",blockquote:"blockquote",em:"em",h1:"h1",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"automated-integrationtests",children:"Automated Integrationtests"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Warum?"}),"\nIntegrationstests stellen sicher dass der Code tut was er soll. Diese wiederkehrende T\xe4tigkeit nicht zu automatisieren w\xe4re Zeitverschwendung."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Die fundamentale Voraussetzung f\xfcr jegliche \xc4nderungen am Code haben wir bereits im\xa0",(0,r.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Grade/Roter%20Grad",children:"Roten Grad"}),"\xa0durch den Einsatz eines Versionskontrollsystems gelegt. Wir k\xf6nnen ohne Sorge \xc4nderungen am Code vornehmen, ganze Dateien und Verzeichnisse l\xf6schen, durch das Versionskontrollsystem ist alles wieder abrufbar."]}),"\n",(0,r.jsxs)(n.p,{children:["Wenn wir nun \xc4nderungen am Code vornehmen, sollten wir uns sicher sein, dass wir dabei nichts kaputt machen. Und diese Sicherheit k\xf6nnen wir nur erlangen, wenn wir nach der \xc4nderung testen, ob die Anwendung sich noch so verh\xe4lt wie zuvor. Diese Tests nach jeder \xc4nderung per Hand durchzuf\xfchren w\xe4re nicht praktikabel, wir m\xfcssen sie automatisieren. Ein gro\xdfes \xdcbel der Softwareentwicklung ist die Angst, bei \xc4nderungen am Code etwas zu \xfcbersehen, ein Detail nicht zu ber\xfccksichtigen, und dadurch einen Fehler zu verursachen in Code der vorher funktionierte. Dabei spielt es in der Regel sogar nicht mal eine Rolle, ob die \xc4nderungen dazu f\xfchren sollen, dass der Code verbessert wird (",(0,r.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Refaktorisieren",children:"Refaktorisieren"}),") oder zus\xe4tzliche Anforderungen umgesetzt werden sollen. Solange wir nach Durchf\xfchren einer \xc4nderung nicht sicher sind, dass alles noch so funktioniert wie zuvor, bleibt die Angst. Diese f\xfchrt dazu, dass wir Code im Zweifelsfall so belassen, wie er ist, denn er funktioniert ja. Notwendige Refaktorisierungen werden unterlassen, aus Angst Fehler zu machen."]}),"\n",(0,r.jsxs)(n.p,{children:["Damit wir uns auch in schon laufenden Projekten (sogenannte\xa0",(0,r.jsx)(n.em,{children:"Brownfield"}),"\xa0Projekte, im Gegensatz zu\xa0",(0,r.jsx)(n.em,{children:"Greenfield"}),"\xa0\u201eauf der gr\xfcnen Wiese\u201c) dieses Sicherheitsnetz schaffen k\xf6nnen, ben\xf6tigen wir Verfahren, die auf vorhandenen Code angewendet werden k\xf6nnen. Dazu eignen sich automatisierte Integrationstests. Sie setzen entweder ganz oben auf der Benutzerschnittstelle auf und testen die Anwendung durch alle Layer oder setzen weiter unten auf. In jedem Fall werden mehrere Funktionseinheiten im Zusammenspiel getestet."]}),"\n",(0,r.jsxs)(n.p,{children:["Bevor wir also \xc4nderungen oder Erweiterungen am Code vornehmen, erstellen wir f\xfcr die betroffenen Codebereiche Integrationstests. Dabei k\xf6nnen Tools und Techniken wie WatiN, UI Automation, etc. verwendet werden. W\xfcnschenswert sind nat\xfcrlich auch ",(0,r.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Unit%20Test",children:"Unit Tests"}),", welche einzelne Funktionseinheiten isoliert testen. Dazu muss der Code allerdings Voraussetzungen erf\xfcllen, die vermutlich nicht immer gegeben sind: der Code muss bereits das\xa0_ ",(0,r.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Single%20Responsibility%20Principle",children:"Single Responsibility Principle"}),"_\xa0ber\xfccksichtigen. Andernfalls sind die Abh\xe4ngigkeiten zwischen den Funktionseinheiten (Komponenten, Klassen oder Methoden) so gro\xdf, dass sie nicht isoliert getestet werden k\xf6nnen. Das Fernziel ist nat\xfcrlich eine Codebasis, bei der ",(0,r.jsx)(n.a,{href:"docs/main/CleanCode/1.%20CleanCodeDeveloper/Unit%20Test.md",children:"Unit Tests"})," m\xf6glich sind. Mehr noch: wir werden in Zukunft die Tests vor der Implementierung erstellen (",(0,r.jsx)(n.em,{children:"Test first"}),"). Aber um durch Refaktorisierungen dorthin zu gelangen, bedarf es erst der Integrationstests, um sicherzustellen, dass die Anwendung sich noch so verh\xe4lt wie vor der ",(0,r.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Refaktorisieren",children:"Refaktorisierung"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var r=t(67294);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);