"use strict";(self.webpackChunkknowledgebase=self.webpackChunkknowledgebase||[]).push([[1883],{22473:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var t=i(85893),r=i(11151);const a={title:"Implementation Reflects Design",aliases:null,tags:["cleancode","cleancode/ccd","cleancode/ccd/principle"]},l="Implementation Reflects Design",s={id:"main/CleanCode/CleanCodeDeveloper/Prinzipien/Implementation Reflects Design",title:"Implementation Reflects Design",description:"tags: #cleancode",source:"@site/docs/main/CleanCode/1. CleanCodeDeveloper/Prinzipien/Implementation Reflects Design.md",sourceDirName:"main/CleanCode/1. CleanCodeDeveloper/Prinzipien",slug:"/main/CleanCode/CleanCodeDeveloper/Prinzipien/Implementation Reflects Design",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Implementation Reflects Design",draft:!1,unlisted:!1,tags:[{label:"cleancode",permalink:"/docs/tags/cleancode"},{label:"cleancode/ccd",permalink:"/docs/tags/cleancode-ccd"},{label:"cleancode/ccd/principle",permalink:"/docs/tags/cleancode-ccd-principle"}],version:"current",frontMatter:{title:"Implementation Reflects Design",aliases:null,tags:["cleancode","cleancode/ccd","cleancode/ccd/principle"]},sidebar:"cs",previous:{title:"Favour Composition over Inheritance",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Favour Composition over Inheritance"},next:{title:"Information Hiding Principle",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Information Hiding Principle"}},o={},d=[];function c(e){const n={a:"a",blockquote:"blockquote",h1:"h1",li:"li",ol:"ol",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"tags: #cleancode"}),"\n",(0,t.jsx)(n.h1,{id:"implementation-reflects-design",children:"Implementation Reflects Design"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Warum?"}),"\nUmsetzung, die von der Planung beliebig abweichen kann, f\xfchrt direkt in die Unwartbarkeit. Umsetzung braucht daher einen durch die Planung vorgegebenen physischen Rahmen."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Architektur und Implementation sollen nicht \xfcberlappen, damit sie das ",(0,t.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/DRY",children:"DRY"}),"-Prinzip nicht verletzten. So werden Inkonsistenzen vermieden, die dadurch entstehen k\xf6nnen, dass auf der einen Seite etwas ge\xe4ndert wird, ohne diese \xc4nderung auf der anderen Seite nachzuf\xfchren."]}),"\n",(0,t.jsx)(n.p,{children:"Nichtsdestotrotz macht die Architektur aber ja Aussagen \xfcber die Implementation. Nicht ihre Details, aber ihre grunds\xe4tzliche Form. Architektur definiert die Strukturelemente und deren Beziehungen innerhalb eines Codesystems. Implementation existiert also auch bei Abwesenheit von \xdcberlappungen nicht unabh\xe4ngig von Architektur, sondern sozusagen in ihr."}),"\n",(0,t.jsx)(n.p,{children:"Genau das sollte sich dann aber auch in der Implementation ausdr\xfccken. So wird die leichter verst\xe4ndlich, so kann besser sichergestellt werden, dass die Implementation tats\xe4chlich der Architektur folgt. Die von der Architektur auf verschiedenen Abstraktionsebenen definierten Strukturelemente sollten deshalb nicht in einem gro\xdfen \u201eCodetopf\u201c (z.b. eine gro\xdfe Visual Studio Solution) \u201ezusammenger\xfchrt werden\u201c. Viel besser auch im Sinne hoher Produktivit\xe4t und einfacher Testbarkeit ist es, die logischen Strukturen der Architektur so physisch wie m\xf6glich zu manifestieren."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Die von der Architektur geplanten Strukturen auf verschiedenen Abstraktionsebenen sollten sich so weitgehend wie m\xf6glich in der Codeorganisation widerspiegeln. Das bedeutet zum einen, dass die Architektur als Strukturelemente vor allem physische Codeeinheiten benutzt. Und zum anderen sollen diese Strukturelemente dann aber auch im Quellcode bzw. in der Codeorganisation im Repository klar sichtbar sein."}),"\n",(0,t.jsx)(n.li,{children:"Bei der Arbeit an der Implementation der Strukturelemente und insbesondere innerhalb von Komponenten sollen Architektur\xe4nderungen \u201eim Vorbeigehen\u201c unm\xf6glich sein. Wer in bzw. an einem Strukturelement arbeitet, also an einem Teil, darf nicht ad hoc die umliegende Struktur, d.h. das Ganze, \xe4ndern k\xf6nnen. Nur wenn das gew\xe4hrleistet ist, w\xe4chst die Entropie einer Software nicht unkontrolliert. Das ist wichtig, da das Hauptziel von Architektur ist, die Entropie und damit die Komplexit\xe4t von Software zu minimieren."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Planung muss sein. Implementation darf Planung nicht torpedieren. (Wenn auch Erkenntnisse w\xe4hrend der Implementation nat\xfcrlich auf die Planung zur\xfcckwirken d\xfcrfen.) Deshalb sind Planung und Implementation zu entkoppeln. Und wo das nicht m\xf6glich ist, da sollte die Planung mit Mitteln der Implementation arbeiten und die Implementation physisch die Planung widerspiegeln."})]})}function u(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>s,a:()=>l});var t=i(67294);const r={},a=t.createContext(r);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);