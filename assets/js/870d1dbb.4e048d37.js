"use strict";(self.webpackChunkknowledgebase=self.webpackChunkknowledgebase||[]).push([[7598],{86054:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>t,metadata:()=>a,toc:()=>c});var r=i(85893),s=i(11151);const t={title:"Open Closed Principle",tags:["cleancode","cleancode/ccd","cleancode/ccd/principle"]},l="Open Closed Principle (OCP)",a={id:"main/CleanCode/CleanCodeDeveloper/Prinzipien/Open Closed Principle",title:"Open Closed Principle",description:"Weil das Risiko, durch neue Features ein bisher fehlerfreies System zu instabilisieren, so gering wie m\xf6glich gehalten werden sollte.",source:"@site/docs/main/CleanCode/1. CleanCodeDeveloper/Prinzipien/Open Closed Principle.md",sourceDirName:"main/CleanCode/1. CleanCodeDeveloper/Prinzipien",slug:"/main/CleanCode/CleanCodeDeveloper/Prinzipien/Open Closed Principle",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Open Closed Principle",draft:!1,unlisted:!1,tags:[{label:"cleancode",permalink:"/docs/tags/cleancode"},{label:"cleancode/ccd",permalink:"/docs/tags/cleancode-ccd"},{label:"cleancode/ccd/principle",permalink:"/docs/tags/cleancode-ccd-principle"}],version:"current",frontMatter:{title:"Open Closed Principle",tags:["cleancode","cleancode/ccd","cleancode/ccd/principle"]},sidebar:"cs",previous:{title:"Law of Demeter",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Law of Demeter"},next:{title:"Principle of Least Astonishment",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Prinzipien/Principle of Least Astonishment"}},d={},c=[];function o(e){const n={a:"a",code:"code",em:"em",h1:"h1",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"open-closed-principle-ocp",children:"Open Closed Principle (OCP)"}),"\n",(0,r.jsxs)(n.p,{children:[":::question ",(0,r.jsx)(n.strong,{children:"Warum?"})]}),"\n",(0,r.jsx)(n.p,{children:"Weil das Risiko, durch neue Features ein bisher fehlerfreies System zu instabilisieren, so gering wie m\xf6glich gehalten werden sollte.\n:::"}),"\n",(0,r.jsxs)(n.p,{children:["Das\xa0",(0,r.jsx)(n.em,{children:"Open Closed Principle"})," (",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle",children:"OCP"}),") besagt, dass eine Klasse offen f\xfcr Erweiterungen sein muss, jedoch geschlossen gegen\xfcber Modifikationen. Es ist ein weiteres der ",(0,r.jsx)(n.a,{href:"/docs/main/CleanCode/SOLID",children:"SOLID"}),"-Prinzipien"]}),"\n",(0,r.jsx)(n.p,{children:"Prinzipien. Folgendes Codebeispiel soll verdeutlichen, wo das Problem liegt, wenn das Prinzip nicht befolgt wird:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public double Preis() {\n\n\xa0 \xa0 const decimal StammkundenRabatt = 0.95m;\n\n\xa0 \xa0 switch(kundenart) {\n\n\xa0 \xa0 \xa0 \xa0 case Kundenart.Einmalkunde:\n\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 return menge * einzelpreis;\n\n\xa0 \xa0 \xa0 \xa0 case Kundenart.Stammkunde:\n\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 return menge * einzelpreis * StammkundenRabatt;\n\n\xa0 \xa0 \xa0 \xa0 default:\n\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 throw new ArgumentOutOfRangeException();\n\n\xa0 \xa0 }\n\xa0 \xa0 \n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Das problematische an dieser Form der Implementierung ist, dass die Klasse modifiziert werden muss, wenn eine weitere Art der Preisberechnung erforderlich wird. Die Gefahr dabei ist, dass bei dieser Modifikation Fehler gemacht werden und die bisher schon vorhandenen Funktionen nicht mehr ordnungsgem\xe4\xdf funktionieren. Auch wenn automatisierte ",(0,r.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Unit%20Test",children:"Unit Tests"})," und ",(0,r.jsx)(n.a,{href:"docs/main/CleanCode/1.%20CleanCodeDeveloper/Integration%20Tests.md",children:"Integrationstests"})," vorhanden sind besteht das Risiko, neue Bugs zu hinterlassen, weil man keine hundertprozentige Testabdeckung erreichen kann. Gesucht ist also generell ein Verfahren, welches die Klasse erweiterbar macht, ohne dass dazu die Klasse selbst modifiziert werden muss. Dies kann z.B. mit Hilfe des\xa0",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.a,{href:"/docs/main/CleanCode/DesignPatterns/Strategy",children:"Strategy Patterns"})})," erreicht werden:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public interface IPreisRechner {\n\n\xa0 \xa0 double Preis(int menge, double einzelpreis);\n\n}\n\nprivate IPreisRechner preisRechner;\n\npublic double Preis() {\n\xa0 \xa0 return preisRechner.Preis(menge, einzelpreis);\n} \n\npublic class Einmalkunde : IPreisRechner {\n\n\xa0 \xa0 public double Preis(int menge, double einzelpreis) {\n\xa0 \xa0 \xa0 \xa0 return menge * einzelpreis;\n\xa0 \xa0 }\n\n}\npublic class Stammkunde : IPreisRechner {\n\n\xa0 \xa0 const decimal StammkundenRabatt = 0.95m;\n\xa0 \xa0 \n\xa0 \xa0 public double Preis(int menge, double einzelpreis) {\n\xa0 \xa0 \xa0 \xa0 return menge * einzelpreis * StammkundenRabatt;\n\xa0 \xa0 }\n\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Die konkrete Berechnung des Preises wird \xfcber ein Interface in andere Klassen ausgelagert. Dadurch ist es m\xf6glich, jederzeit neue Implementierungen des Interfaces zu erg\xe4nzen. Damit ist die Klasse offen f\xfcr Erweiterungen, gleichzeitig aber geschlossen gegen\xfcber Modifikationen. Bestehender Code kann z.B. mit dem ",(0,r.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Refaktorisieren",children:"Refactoring"}),"\xa0",(0,r.jsx)(n.a,{href:"http://www.industriallogic.com/xp/refactoring/conditionalWithStrategy.html",children:"Replace Conditional with Strategy"})," so umgestaltet werden, dass das Open Closed Principle eingehalten wird."]})]})}function p(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>l});var r=i(67294);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);