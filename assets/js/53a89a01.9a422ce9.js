"use strict";(self.webpackChunkknowledgebase=self.webpackChunkknowledgebase||[]).push([[7146],{52025:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var t=i(85893),r=i(11151);const s={title:"Component Orientation",aliases:null,tags:["cleancode","cleancode/ccd","cleancode/ccd/practic"]},o="Component Orientation",a={id:"main/CleanCode/CleanCodeDeveloper/Praktiken/Component Orientation",title:"Component Orientation",description:"Warum?",source:"@site/docs/main/CleanCode/CleanCodeDeveloper/Praktiken/Component Orientation.md",sourceDirName:"main/CleanCode/CleanCodeDeveloper/Praktiken",slug:"/main/CleanCode/CleanCodeDeveloper/Praktiken/Component Orientation",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Praktiken/Component Orientation",draft:!1,unlisted:!1,tags:[{label:"cleancode",permalink:"/docs/tags/cleancode"},{label:"cleancode/ccd",permalink:"/docs/tags/cleancode-ccd"},{label:"cleancode/ccd/practic",permalink:"/docs/tags/cleancode-ccd-practic"}],version:"current",frontMatter:{title:"Component Orientation",aliases:null,tags:["cleancode","cleancode/ccd","cleancode/ccd/practic"]},sidebar:"cs",previous:{title:"Complex Refactorings",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Praktiken/Complex Refactorings"},next:{title:"Continuous Delivery",permalink:"/docs/main/CleanCode/CleanCodeDeveloper/Praktiken/Continuous Delivery"}},l={},d=[];function c(e){const n={a:"a",blockquote:"blockquote",em:"em",h1:"h1",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"component-orientation",children:"Component Orientation"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Warum?"}),"\nSoftware braucht Black-Box-Bausteine, die sich parallel entwickeln und testen lassen. Das f\xf6rdert Wandelbarkeit, Produktivit\xe4t und Korrektheit."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Die Prinzipien des\xa0",(0,t.jsx)(n.a,{href:"docs/main/CleanCode/CleanCodeDeveloper-Wertesystems"}),"\xa0haben sich bisher vor allem auf kleinere Codeausschnitte bezogen. Was sollte in einer Methode stehen, was sollte \xfcber mehrere verteilt werden? Welche Methoden sollte eine Klasse ver\xf6ffentlichen? Woher sollte ein Client-Objekt zu einem Service-Objekt kommen? Bisher ging es um Prinzipien f\xfcr die Softwareentwicklung im Kleinen."]}),"\n",(0,t.jsxs)(n.p,{children:["Hat das ",(0,t.jsx)(n.a,{href:"docs/main/CleanCode/CleanCodeDeveloper-Wertesystem"})," denn aber nichts zu gr\xf6\xdferen Strukturen, zur Softwareentwicklung im Gro\xdfen zu sagen? Wie steht es mit der Softwarearchitektur? Genau hier setzt das Prinzip der Komponentenorientierung an. Bisher haben wir zwar auch schon das Wort \u201eKomponente\u201c gebraucht, doch eher lax und in einem umgangssprachlichen Sinn. Von nun an jedoch soll\xa0",(0,t.jsx)(n.em,{children:"Komponente"}),"\xa0etwas sehr spezifisches beschreiben, das wir f\xfcr grundlegend f\xfcr evolvierbare Software halten."]}),"\n",(0,t.jsx)(n.p,{children:"Solange wir Software letztlich nur aus Klassen mit Methoden aufgebaut denken, versuchen wir sozusagen Computer auf Transistorebene zu beschreiben. Das funktioniert letztlich aber nicht, weil wir im Detailreichtum ersticken. Selbst die Klassen in Schichten zusammenzufassen hilft da nicht viel. Wir brauchen vielmehr sowohl ein Beschreibungsmittel f\xfcr gr\xf6\xdfere Softwarestrukturen. Aber nicht nur das: das Beschreibungsmittel sollte auch ein Implementationsmittel sein \u2013 so wie Klassen -, damit das Modell, der Plan, die Beschreibung sich im Code widerspiegelt."}),"\n",(0,t.jsx)(n.p,{children:"Betriebssystemprozesse sind zwar solche architektonischen Mittel, letztlich sind auch sie jedoch zu gro\xdf. Solange die EXE eines Prozesses einer Applikation aus mehreren Hundert oder Tausend Klassen besteht, gewinnen wir nichts."}),"\n",(0,t.jsx)(n.p,{children:"Hilfe bringt allerdings das Prinzip der Komponentenorientierung. Es besagt, dass ein Anwendungsprozess zun\xe4chst einmal aus Komponenten besteht und nicht aus Klassen. Erst die Bausteine der Komponenten sind dann Klassen. Und was ist eine Komponente? Es gibt einige Definitionen f\xfcr Komponenten, von denen im Kern zwei Kriterien unverbr\xfcchlich erscheinen:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Komponenten sind bin\xe4re Funktionseinheiten. (Eine Klasse hingegen ist eine Funktionseinheit auf Quellcodeebene.)"}),"\n",(0,t.jsx)(n.li,{children:"Die Leistung von Komponenten wird durch einen separaten (!) Kontrakt beschrieben. (Die Leistungsbeschreibung einer Klasse liegt hingegen in ihr. Es ist die Summe ihrer Methodensignaturen.)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Ein [CCD](docs/main/CleanCode/CleanCodeDeveloperwurf einer Software nach der Definition der Prozesse also zun\xe4chst nach den Komponenten, aus denen die Prozesse bestehen sollten. Er fragt sich, welche \u201eDienstleistungsbl\xf6cke\u201c machen die Anwendung aus? Und diese Bl\xf6cke sieht der [CCD](docs/main/CleanCode/CleanCodeDeveloper.CleanCodeDevelopern Aufbau aus Klassen an. Diese Bl\xf6cke sind Assemblies mit wohldefinierter Dienstleistung, aber unbekannter Struktur."}),"\n",(0,t.jsx)(n.p,{children:"Eine Client-Komponente C wei\xdf daher nichts \xfcber die Klassenstruktur ihrer Service-Komponente S. C kennt nur den Kontrakt von S, der unabh\xe4ngig von der Implementation von S ist. Kontrakte sind insofern f\xfcr Komponenten das, was Interfaces f\xfcr Klassen sind. Nicht zuf\xe4llig bestehen Kontrakte zu einem guten Teil oder gar vollst\xe4ndig aus Interfaces."}),"\n",(0,t.jsxs)(n.p,{children:["Komponenten sind also Elemente der Planung wie auch der Implementation. Um das zu unterstreichen, werden Komponenten physisch unabh\xe4ngig voneinander implementiert; ein probates Mittel daf\xfcr sind\xa0",(0,t.jsx)(n.em,{children:"Komponentenwerkb\xe4nke"}),", d.h. separate Visual Studio Solutions je Komponentenimplementation. Das f\xf6rdert nicht nur die Konzentration auf eine Aufgabe, weil man w\xe4hrend der Arbeit an einer Komponente in der IDE nur deren Code sieht. Dar\xfcber hinaus f\xf6rdert es auch konsequente ",(0,t.jsx)(n.a,{href:"/docs/main/CleanCode/CleanCodeDeveloper/Unit%20Test",children:"Unit Tests"})," unter Einsatz von Attrappen, da Quellcode anderer Komponenten nicht sichtbar ist. Au\xdferdem steigert solche Codeorganisation die Produktivit\xe4t, weil Komponenten dank ihrer separaten Kontrakte parallel implementiert werden k\xf6nnen. Und schlie\xdflich stellt sich eine physische Isolation gegen den schleichenden Zuwachs an Entropie im Code. Denn wo Bindungen zwischen Komponenten nur via Kontrakt aufgebaut werden k\xf6nnen, ist die Kopplung lose und kontrolliert."]}),"\n",(0,t.jsxs)(n.p,{children:["Zur Komponentenorientierung geh\xf6ren deshalb nicht nur bin\xe4re, gr\xf6\xdfere Codeeinheiten mit separaten Kontrakten, sondern auch die Entwicklung der Kontrakte vor der Implementation (",(0,t.jsx)(n.em,{children:"Contract-first Design"}),"). Denn sobald die Kontrakte definiert sind, die eine Komponente importiert und exportiert, kann die Arbeit an der Komponente unabh\xe4ngig von allen anderen beginnen."]}),"\n",(0,t.jsxs)(n.p,{children:["Siehe auch unter\xa0",(0,t.jsx)(n.a,{href:"https://clean-code-developer.de/weitere-infos/werkzeuge/",children:"Tools"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>o});var t=i(67294);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);